#!/bin/sh
# restore.sh: tests rmw's restore features
#
# This script can be used to demonstrate the restore features of rmw to
# new users, and to test for bugs when making code changes
#

. @abs_builddir@/VARS

if [ -e COMMON ]; then
  . ./COMMON
else
  . @abs_top_srcdir@/test/COMMON
fi

echo $SEPARATOR
echo "Initialize"
$RMW_TEST_CMD_STRING || exit $?

echo $SEPARATOR
echo "If the mrl file doesn't exist yet..."
expected="no items in the list"
output=$($VALGRIND $RMW_TEST_CMD_STRING -u) || exit $?
test "${output}#*${substring}" != "${output}" || exit $?
echo $output

echo $SEPARATOR
echo " Creating some files for testing..."
cd ${RMW_FAKE_HOME}
@abs_builddir@/create-some-files.sh || exit $?

echo $SEPARATOR
echo "Try to restore files that aren't in a Waste/files folder"
substring="not in a Waste directory"
output=$($VALGRIND $RMW_TEST_CMD_STRING -z ${RMW_FAKE_HOME}/somefiles/* 2>&1) || test_result_want_fail $?
test "${output#*$substring}" != "$output" || exit $?

echo $SEPARATOR
echo "ReMove files and then restore them by using -u"
set -x
$RMW_TEST_CMD_STRING ${RMW_FAKE_HOME}/somefiles/* || exit $?
echo $SEPARATOR
output=$($VALGRIND $RMW_TEST_CMD_STRING -uvv | grep Waste) || exit $?
echo $SEPARATOR
test "$output" = "+'${RMW_FAKE_HOME}/.Waste/files/read_only_file' -> '${RMW_FAKE_HOME}/somefiles/read_only_file'
-${RMW_FAKE_HOME}/.Waste/info/read_only_file.trashinfo
+'${RMW_FAKE_HOME}/.Waste/files/topdir' -> '${RMW_FAKE_HOME}/somefiles/topdir'
-${RMW_FAKE_HOME}/.Waste/info/topdir.trashinfo" || exit $?

echo $SEPARATOR
echo "Show result when no undo file exists..."
output=$($VALGRIND ${RMW_TEST_CMD_STRING} -u) || exit $?
test "${output}" = "There are no items in the list - please check back later."

echo $SEPARATOR
echo "restore using wildcard pattern, but be in the trash directory"
set -x
$RMW_TEST_CMD_STRING ${RMW_FAKE_HOME}/somefiles/topdir -v || exit $?
cd $PRIMARY_WASTE_DIR/files
$VALGRIND $RMW_TEST_CMD_STRING -z topd* || exit $?
test -e "${RMW_FAKE_HOME}/somefiles/topdir" || exit $?

echo $SEPARATOR
echo "Try restoring a file that doesn't exist"
$VALGRIND $RMW_TEST_CMD_STRING -z nonexistent_fil*
test_result_want_fail $?

# This test is inaccurate when run with superuser privileges.

#echo $SEPARATOR
#echo "What happens when trying to ReMove file inside dir with no write permissions..."
#set -x
#mkdir ${RMW_FAKE_HOME}/no_write_perms
#touch ${RMW_FAKE_HOME}/no_write_perms/test.tmp
#chmod -R -w ${RMW_FAKE_HOME}/no_write_perms
#$RMW_TEST_CMD_STRING ${RMW_FAKE_HOME}/no_write_perms
#test_result_want_fail $?

echo $SEPARATOR
echo "Symlinks"
ln -s ${RMW_FAKE_HOME} ${RMW_FAKE_HOME}/link_test || exit $?
# broken link
ln -s broken_symlink_test ${RMW_FAKE_HOME}/link_test2 || exit $?
$VALGRIND $RMW_TEST_CMD_STRING ${RMW_FAKE_HOME}/link_test ${RMW_FAKE_HOME}/link_test2 || exit $?
test -h "${PRIMARY_WASTE_DIR}/files/link_test" || exit $?

${RMW_TEST_CMD_STRING} -u || exit $?
test -h "${RMW_FAKE_HOME}/link_test2" || exit $?

# change permissions back to writable so the dir gets removed before the
# next test (done in COMMON)
chmod +w -R ${RMW_FAKE_HOME}/no_write_perms

# test using relative path and dotfiles
cd ${RMW_FAKE_HOME}
mkdir tmpfoo
for t in "foo" "bar" ".boo" ".far"; do
  touch tmpfoo/$t
  ${RMW_TEST_CMD_STRING} tmpfoo/$t || exit $?
  cat ${PRIMARY_WASTE_DIR}/info/$t.trashinfo || exit $?
  cd ${PRIMARY_WASTE_DIR}
  ${RMW_TEST_CMD_STRING} -z files/$t || exit $?
  cd ${RMW_FAKE_HOME}
  test -f tmpfoo/$t || exit $?
done

# Now try dotfiles with wildcards
for t in ".boo" ".far"; do
  touch tmpfoo/$t
  ${RMW_TEST_CMD_STRING} tmpfoo/.* || exit $?
  ${RMW_TEST_CMD_STRING} -z ${PRIMARY_WASTE_DIR}/files/$t || exit $?
  test -f tmpfoo/$t || exit $?
done

# a dot dir
substring="refusing to process"
output="$(${RMW_TEST_CMD_STRING} -z ${PRIMARY_WASTE_DIR}/files/.)"
test "${output#*$substring}" != "${output}" || exit $?

if -n "${TERM}"; then
  echo q | ${VALGRIND} ${RMW_TEST_CMD_STRING} -s || exit $?
fi

# This test will only work on Andy's workstation.
# The media root, /home/andy/src is on a different partition than /home/andy
# It's mounted with 'bind' and therefore has a different device id
#
# /dev/sda7 on /mnt/sda7 type ext4 (rw,relatime)
# /dev/sda7 on /home/andy/src type ext4 (rw,relatime)

if test -f "@abs_builddir@/4507107f3ff0df740c7699fb9dc4cecc041c59c9"; then
  test_file="media_root_test"
  PREV_RMW_FAKE_HOME=${RMW_FAKE_HOME}
  # needs to be unset so rmw will use $HOME instead
  unset RMW_FAKE_HOME
  test_file_path=${PREV_RMW_FAKE_HOME}/$test_file
  if test -f $test_file_path; then
    rm $test_file_path
  fi
  if test -f /home/andy/src/.Trash-1000/files/$test_file; then
    rm /home/andy/src/.Trash-1000/files/$test_file
  fi
  if test -f /home/andy/src/.Trash-1000/info/$test_file.trashinfo; then
    rm /home/andy/src/.Trash-1000/info/$test_file.trashinfo
  fi
  touch $test_file_path
  $BIN_DIR/rmw -c /home/andy/.config/rmwrc $test_file_path || exit $?
  echo $SEPARATOR
  output=$(grep Path /home/andy/src/.Trash-1000/info/$test_file.trashinfo) || exit $?
  echo $SEPARATOR
  # There should be no leading '/' in the filename.
  test "$output" = "Path=rmw-project/_build/test/rmw-tests-home/test_restore.sh_dir/media_root_test" || exit $?
  echo $SEPARATOR
  output=$($BIN_DIR/rmw -uvv -c /home/andy/.config/rmwrc | grep media_root_test) || exit $?
  echo $SEPARATOR
  test "$output" = "+'/home/andy/src/.Trash-1000/files/media_root_test' -> '/home/andy/src/rmw-project/_build/test/rmw-tests-home/test_restore.sh_dir/media_root_test'
-/home/andy/src/.Trash-1000/info/media_root_test.trashinfo" || exit $?
fi

echo $SEPARATOR
echo "restore tests passed"

exit 0
